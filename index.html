<html>
  <head>
    <meta charset="utf-8">
    <title>asciink</title>
    <link rel="stylesheet" href="code-mirror-lib/codemirror.css">
    <style>
      :root {
        --bar-height: 32px;
      }

      body {
        margin: 0;
        padding: 0;
        background: #222;
        color: white;
        display: flex;
        justify-content: center;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
      }

      .main {
        width: 100vw;
        max-width: 1600px;
        height: calc(100vh - var(--bar-height));
        border: 2px solid #444;
        display: flex;
        flex-direction: row;
      }

      .bar {
        height: var(--bar-height);
        color: white;
        display: flex;
        align-items: center;
      }
      
      .left {
        width: 50%;
        height: 100%;
      }
      
      .right {
        width: 50%;
        height: 100%;
        background: #444;
      }

      #story {
        width: 100%;
        height: 100%;
      }

      .CodeMirror {
        width: 100%;
        height: 100%;
      }

      .text {
        background: #222;
      }

      .choice {
        background: #222;
        color: #0f0;
      }

      .CodeMirror-gutters {
        background-color: #222;
        border-right: 2px solid #444;
      }

      .CodeMirror-linenumber {
          color: #fff;
      }

      .CodeMirror-overwrite .CodeMirror-cursor {
        width: auto;
        border-left: 1px solid red;
      }

      #play {
        width: 480px;
        height: 320px;
        color: white;
        position: absolute;
        font-family: monospace;
        padding: 8px;
      }

      #map-canvas {
        width: 480px;
        height: 320px;
        border: 0px solid #888;
      }

      textarea {
        resize: none;
        background: #222;
        color: white;
        font-family: monospace;
        font-size: 14px;
        padding: 7px;
      }

      button {
        max-height: calc(var(--bar-height) - 4px);
        font-size: 12px;
        margin: 4px;
      }

    </style>
  </head>
  <body>
    <div class="app">
      <div class="main">
        <div class="left">
          <div id="story"></div>
        </div>
        <div class="right">
          <div id="play"></div>
          <canvas id="map-canvas" width="480" height="320"></canvas>
        </div>
      </div>
      <div class="bottom-bar bar">
        <button id="play-button">Play</button>
        <button id="save-button">Save</button>
      </div>
    </div>
  </body>

  <script src="code-mirror-lib/codemirror.js"></script>
  <script src="./ink/ink-full.js"></script>

  <script id="scr">

    const delay = 400

    const mapWidth = 48
    const mapHeight = 24

    function error(msg) {
      console.log("COMPILE ERROR", msg)
      document.getElementById("play").innerHTML = `
          ${msg}
      `
    }

    const autoSave = "buffy summers"

    const vision = 7.5
    const vision4Entity = 5.5
    const visionYStretch = 1

    let codeMirror
    let outputDiv
    let story = null
    let authorData = null
    let entities = []
    let ctx = null
    let player = {x: 3, y: 3}

    window.onload = startApp
    function startApp() {
      outputDiv = document.getElementById("play")

      codeMirror = CodeMirror(document.getElementById("story"), {
        value: "",
        indentUnit: 2,
        tabSize: 2,
        indentWithTabs: false,
        lineNumbers: true,
        lineWrapping: false,
        spellcheck: false,
        lineWrapping: true,
        extraKeys: {
          "Shift-Tab": "indentLess",
        },
      })

      document.addEventListener("keyup", (ev) => {
        const k = ev.key
        let oldX = player.x
        let oldY = player.y
        if (k === "1" || k === "2" || k === "3" || k === "4" || k === "5" || k === "6" ||
            k === "7" || k === "8" || k === "9") {
          const num = Number(k)
          takeTurn(num - 1)
          return
        }
        let walked = false
        if (k === "ArrowUp" || k === "w") {player.y --; walked = true}
        if (k === "ArrowDown" || k === "s") {player.y ++; walked = true}
        if (k === "ArrowRight" || k === "d") {player.x ++; walked = true}
        if (k === "ArrowLeft" || k === "a") {player.x --; walked = true}
        if (!walked) return
        const map = getCurrentMap()
        let char
        let block = false
        if (!map[player.y]) {
          block = true
        } else if (!map[player.y][player.x]) {
          block = true
        } else {
          char = map[player.y][player.x]
          if (char !== "." && char !== " " && char !== "$") block = true
        }
        if (block) {
          player.x = oldX
          player.y = oldY
        }
        for (const entity of entities) {
          if (player.x === entity.x && player.y === entity.y) {
            renderMap()
            startTalk(entity)
            return
          }
        }
        if (oldX !== player.x || oldY !== player.y) {
          cls()
          renderMap()
        }
      })

      document.getElementById("play-button").addEventListener("click", (ev) => {
        document.getElementById("play").innerHTML = ""
        const v = codeMirror.getValue()
        const [err, dataObj, inkCode] = preprocess(v)
        console.log("dataObj", dataObj)
        if (err) {
          error(err)
          return
        }
        try {
          const compiler = new inkjs.Compiler(inkCode)
          compiler.OnError = (...args) => {error(...args)}
          story = compiler.Compile()
          console.log(compiler, story)
        } catch(err) {
          console.log("error?", err)
          return
        }
        authorData = dataObj
        story.onError = (...args) => error(...args)
        startStory()
      })

      document.getElementById("save-button").addEventListener("click", (ev) => {
        localStorage.setItem(autoSave, codeMirror.getValue())
      })

      if (localStorage.getItem(autoSave)) {
        codeMirror.setValue(localStorage.getItem(autoSave))
      }
    }

    function takeTurn(choiceIndex) {
      if (choiceIndex > story.currentChoices.length - 1) {
        return
      }
      story.ChooseChoiceIndex (choiceIndex)
      doRunStory()
    }

    function doRunStory() {
      while (story.canContinue) {
        const content = story.Continue()
        console.log("text print", content)
        print(content, "text")
      }
      if (story.currentChoices.length > 0) {
        for (let i = 0; i < story.currentChoices.length; i++) {
          const choice = story.currentChoices[i]
          console.log("choice print", choice.text)
          print((i + 1) + ". " + choice.text, "choice")
        }
      }
    }

    function startTalk(entity) {
      try {
        story.ChoosePathString(entity.name)
      } catch {
        error (`No Ink knot with name "${entity.name}"?`)
      }
      doRunStory()
    }

    const getFirstWord = (str) => {
      /* only looks at whitespace.
      has no concept of punctuation or word-forming characters
      so "   word(word2) word3   "
      will return
      "word(word2)" as first word! (NOT: "word")
      */
      const txt = str.trim()
      for (let i = 0; i < txt.length; i++) {
        const char = txt[i]
        if (char.trim() === "") {
          return txt.substring(0, i)
        }
        if (i === txt.length - 1) {
          return txt
        }
      }
      return ""
    }

    const getFirstWordAndRest = (str) => {
      if (str !== str.trim()) {
        throw new Error(`The function "getFirstWordAndRest" in module "utils.js" works
          only with white-space-trimmed strings. You passed a non-white-space trimmed string.`)
      }
      const firstWord = getFirstWord(str)
      return [firstWord, str.substring(firstWord.length)]
    }

    function preprocess(str) {
      let err = false
      let dataObj = {}
      let inkCode = ""
      const parts = str.split("\n@@@===")
      dataObj.header = processHeader(parts[0])
      dataObj.maps = processMaps(parts[1])
      inkCode = parts[2]
      return [err, dataObj, inkCode]
    }

    function processHeader(str) {
      const lines = str.split("\n").map(n => n.trim()).filter(n => n)
      const obj = {}
      for (const line of lines) {
        let [key, rest] = getFirstWordAndRest(line)
        key = key.replace(":", "").trim()
        rest = rest.trim()
        if (rest.startsWith(":")) {
          //if story author does: "property : content"
          //instead of "property: content", fix it:
          rest = rest.substring(1).trim()
        }
        console.log("hummm", key, rest)
        const subobj = {}
        obj[key] = subobj
        const subparts = rest.split(",").map(n => n.trim()).filter(n => n)
        for (subpart of subparts) {
          const parts = subpart.split(":")
          const key = parts[0].trim()
          const value = parts[1].trim()
          console.log(1, key, value)
          subobj[key] = value
        }
      }
      return obj
    }


    function processMaps(str) {
      const mapsObj = {}
      let firstMapName = ""
      const maps = str.split("\nMAP:").map(n => n.trim()).filter(n => n)
      for (const map of maps) {
        let map2 = map.trim()
        const [mapName, rest] = getFirstWordAndRest(map2)
        mapsObj[mapName] = createMap(rest)
        if (!firstMapName) firstMapName = mapName
      }
      mapsObj.$firstMapName = firstMapName
      return mapsObj
    }

    function createMap(str) {
      const lines = str.split("\n")
      let y = -1
      const grid = []
      for (const line of lines) {
        y++
        grid[y] = []
        let x = -1
        if (y > mapHeight) break
        for (const char of line) {
          x++
          if (x > mapWidth) break
          grid[y][x] = char
        }
      }
      adjustMap(grid)
      return grid
    }

    function startStory() {
      ctx = document.getElementById("map-canvas").getContext("2d")
      renderMap()
    }

    function getCurrentMap() {
      const map = authorData.maps[authorData.maps.$firstMapName]
      return map
    }

    function renderMap() {
      const map = getCurrentMap()
      const spaceX = 14
      const spaceY = spaceX
      let ox = 240 - (player.x) * spaceX
      let oy = 160 - (player.y - 1) * spaceY
      const fontSize = spaceX
      ctx.font = '16px monospace';
      ctx.fillStyle = '#222'
      ctx.fillRect(0, 0, 480, 320)
      ctx.fillStyle = '#fff'
      loopThroughMap(map, (char, x, y) => {
        const distX = Math.abs(x - player.x)
        const distY = Math.abs(y - player.y)
        const dist = Math.sqrt(distX * distX + distY * distY * visionYStretch)
        let px = x * spaceX + ox
        let py = y * spaceY + oy
        if (dist > vision) {
          ctx.fillStyle = "#777"
          ctx.fillText("█", px, py)
          ctx.fillStyle = "#fff"
          return
        }
        if (player.x === x && player.y === y) {
          ctx.fillStyle = '#0fc'
          ctx.fillText("$", px, py)
          ctx.fillStyle = '#fff'
          return
        }
        if (char === "." || char === "") return
        if (char === "$") {
          char = "#"
        }
        ctx.fillText(char, px, py)
      })
      ctx.fillStyle = '#c00'
      let i = -1
      for (const entity of entities) {
        i++
        const distX = Math.abs(entity.x - player.x)
        const distY = Math.abs(entity.y - player.y)
        const dist = Math.sqrt(distX * distX + distY * distY * visionYStretch)
        if (distX > vision4Entity) continue
        let px = entity.x * spaceX + ox
        let py = entity.y * spaceY + oy
        ctx.fillText("@", px, py)
      }
    }

    function isEnglishLowerCaseLetter(char) {
      return /^[a-z]$/.test(char)
    }

    function adjustMap(map) {
      let collect = null
      loopThroughMap(map, (char, x, y) => {
        //console.log(char, x, y)
        if (isEnglishLowerCaseLetter(char) || char === ":") {
          if (!collect) {
            collect = char
          } else {
            collect += char
          }
          map[y][x] = "."
        } else {
          if (collect) {
            let xPos = 0
            if (collect.startsWith(":")) {
              xPos = x - collect.length
            } else {
              xPos = x - 1
            }
            entities.push({
              x: xPos,
              y,
              name: collect.replaceAll(":", ""),
            })
            collect = null
          }
        }
      })
    }

    function loopThroughMap(map, func) {
      let y = -1
      for (const item of map) {
        y++
        let x = -1
        for (const item2 of item) {
          x++
          func(item2, x, y)
        }
      }
    }

    function cls() {
      outputDiv.innerHTML = ""
    }

    function print(text, cssClass) {
      outputDiv.innerHTML += `<div class="${cssClass}">${text}</div>`
    }


//_inkStory.ChooseChoiceIndex (index);


  </script>

</html>