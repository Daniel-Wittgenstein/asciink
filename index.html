<html>
  <head>
    <meta charset="utf-8">
    <title>asciink</title>
    <!--DEV-->
    <link rel="stylesheet" href="code-mirror-lib/codemirror.css">
    <!--END_DEV-->
    <style>
      :root {
        --bar-height: 32px;
        --bg: #222;
        --choice-color: yellow;
        --text-color: purple;
        --text-box-padding: 16px;
        --text-box-border-size: 16px;
        --text-box-border-color: white;
      }

      body {
        margin: 0;
        padding: 0;
        background: #222;
        color: white;
        display: flex;
        justify-content: center;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
      }

      .main {
        width: 100vw;
        max-width: 1600px;
        height: calc(100vh - var(--bar-height));
        display: flex;
        flex-direction: row;

        align-items: center;
        justify-content: center;
      }

      .bar {
        height: var(--bar-height);
        color: white;
        display: none;
        align-items: center;
      }
      
      .left {
        width: 50%;
        height: 100%;
        display: none;
      }
      
      .right {
        width: 50%;
        height: 100%;
        background: #444;
      }

      #story {
        width: 100%;
        height: 100%;
      }

      .CodeMirror {
        width: 100%;
        height: 100%;
      }

      .text {
        background: var(--bg);
        color: var(--text-color);
      }

      .choice {
        background: var(--bg);
        color: var(--choice-color);
      }

      .CodeMirror-gutters {
        background-color: #222;
        border-right: 2px solid #444;
      }

      .CodeMirror-linenumber {
          color: #fff;
      }

      .CodeMirror-overwrite .CodeMirror-cursor {
        width: auto;
        border-left: 1px solid red;
      }

      #play {
        width: 480px;
        height: 320px;
        position: absolute;
        font-family: monospace;
        display: none;
      }

      #play-inner {
        padding: 20px;
      }

      #play-inner-most {
        padding: var(--text-box-padding);
        background: var(--bg);
        border: var(--text-box-border-size) solid var(--text-box-border-color);
      }

      #map-canvas {
        width: 480px;
        height: 320px;
        border: 0px solid #888;
      }

      textarea {
        resize: none;
        background: #222;
        color: white;
        font-family: monospace;
        font-size: 14px;
        padding: 7px;
      }

      button {
        max-height: calc(var(--bar-height) - 4px);
        font-size: 12px;
        margin: 4px;
      }

    </style>
  </head>
  <body>
    <div class="app">
      <div class="main">
        <div class="left">
          <div id="story"></div>
        </div>
        <div class="right">
          <div id="play">
            <div id="play-inner">
              <div id="play-inner-most">       
              </div>              
            </div>              
          </div>
          <canvas id="map-canvas" width="480" height="320"></canvas>
        </div>
      </div>
      <div class="bottom-bar bar">
        <button id="play-button">Play</button>
        <button id="save-button">Save</button>
        <button id="export-button">Export</button>
      </div>
    </div>

  <!--DEV-->
  <script src="code-mirror-lib/codemirror.js"></script>
  <script src="./ink/ink-full.js"></script>
  <script src="./auto-generated/exportHtmlData.js"></script>
  <!--END_DEV-->

  <!--INJECT-->

  <!--INJECT_STORY-->

  <script id="scr">

    /* 
      to do:
      - IMPORTANT: show errors set display to block on error
      - export
      - load demo game when no localstorage
      - proper reload play reset entities when testing again etc.
      - docs link or display
      - end game from ink
      - set player start position via tile
      - maybe: show title at beginning
      - maybe: special ink commands:
        - switch map
        - change all tiles value1 to value2
      - maybe: comments inside header block
      - maybe: status bar shows contents of a all special ink variables starting with $, nothing else
    */

    const delay = 400

    const mapWidth = 48
    const mapHeight = 24

    function error(msg) {
      console.log("COMPILE ERROR", msg)
      outputDiv.innerHTML = `${msg}`
    }

    const autoSave = "buffy summers"

    const vision = 7.5
    const vision4Entity = 5.5
    const visionYStretch = 1

    let codeMirror
    let outputDiv
    let story = null
    let authorData = null
    let entities = []
    let ctx = null
    let player = {x: 3, y: 3}

    let EDITOR = true

    function initEditorView() {
      document.querySelector(".left").style.display = "block"
      document.querySelector(".bottom-bar").style.display = "flex"
    }

    function startExportedGame() {
      playIt()      
    }

    window.onload = startApp
    function startApp() {

      if (!window.$exportedHtmlData) {
        EDITOR = false
      }

          //EDITOR = 0 //TESTING ONLY

      if (EDITOR) initEditorView()

      outputDiv = document.getElementById("play-inner-most")

      if (EDITOR) {
        codeMirror = CodeMirror(document.getElementById("story"), {
          value: "",
          indentUnit: 2,
          tabSize: 2,
          indentWithTabs: false,
          lineNumbers: true,
          lineWrapping: false,
          spellcheck: false,
          lineWrapping: true,
          extraKeys: {
            "Shift-Tab": "indentLess",
          },
        })
      }

      document.addEventListener("keyup", (ev) => {
        const k = ev.key
        let oldX = player.x
        let oldY = player.y
        if (k === "1" || k === "2" || k === "3" || k === "4" || k === "5" || k === "6" ||
            k === "7" || k === "8" || k === "9") {
          const num = Number(k)
          takeTurn(num - 1)
          return
        }
        let walked = false
        if (k === "ArrowUp" || k === "w") {player.y --; walked = true}
        if (k === "ArrowDown" || k === "s") {player.y ++; walked = true}
        if (k === "ArrowRight" || k === "d") {player.x ++; walked = true}
        if (k === "ArrowLeft" || k === "a") {player.x --; walked = true}
        if (!walked) return
        const map = getCurrentMap()
        let char
        let block = false
        if (!map[player.y]) {
          block = true
        } else if (!map[player.y][player.x]) {
          block = true
        } else {
          char = map[player.y][player.x]
          if (!authorData.header[char] ||
            !authorData.header[char].pass || authorData.header[char].pass !== "yes") {
              block = true
          }
        }
        if (block) {
          player.x = oldX
          player.y = oldY
        }
        for (const entity of entities) {
          if (player.x === entity.x && player.y === entity.y) {
            renderMap()
            startTalk(entity)
            return
          }
        }
        if (oldX !== player.x || oldY !== player.y) {
          cls()
          renderMap()
        }
      })

      document.getElementById("play-button").addEventListener("click", (ev) => {
        playIt()
      })

      document.getElementById("save-button").addEventListener("click", (ev) => {
        saveProject()
      })

      document.getElementById("export-button").addEventListener("click", (ev) => {
        playIt()
        let ht = window.$exportedHtmlData.data
        ht = ht.replace(/\<title\>.*?\<\/title\>/, () => {
          return "<title>" + (authorData.header.title?.title || "unnamed game") + "</title>"
        })
        const xx = JSON.stringify({data:codeMirror.getValue()})
        ht = ht.replace("<!--INJECT_STORY-->", `
          <script>window.$userStoryData = ${xx}<\/script>
        `)
        download(ht, "export.html")
      })

      if (localStorage.getItem(autoSave)) {
        if (EDITOR) {
          codeMirror.setValue(localStorage.getItem(autoSave))
        }
      }

      if (!EDITOR) startExportedGame()
    }

    function saveProject() {
      if (!EDITOR) return
      localStorage.setItem(autoSave, codeMirror.getValue())
    }

    function takeTurn(choiceIndex) {
      if (choiceIndex > story.currentChoices.length - 1) {
        return
      }
      cls()
      story.ChooseChoiceIndex (choiceIndex)
      doRunStory()
    }

    function playIt() {
      saveProject()
      outputDiv.innerHTML = ""
      let v = ""
      if (EDITOR) v = codeMirror.getValue()
      if (!EDITOR) v = window.$userStoryData.data
      
      const [err, dataObj, inkCode] = preprocess(v)
      console.log("dataObj", dataObj)
      if (err) {
        error(err)
        return
      }
      try {
        const compiler = new inkjs.Compiler(inkCode)
        compiler.OnError = (...args) => {error(...args)}
        story = compiler.Compile()
        console.log(compiler, story)
      } catch(err) {
        console.log("error?", err)
        return
      }
      authorData = dataObj
      story.onError = (...args) => error(...args)
      startStory()
    }


    function download(html, fileName) {
      const blob = new Blob([html], {type: 'text/html'})
      const link = document.createElement("a")
      link.download = fileName
      link.href = window.URL.createObjectURL(blob)
      document.body.appendChild(link)
      link.click()
      document.body.removeChild(link)
    }

    function setCssVar(key, value) {
      document.documentElement.style.setProperty("--" + key, value)
    }


    function doRunStory() {
      while (story.canContinue) {
        const content = story.Continue()
        console.log("text print", content)
        print(content, "text")
      }
      if (story.currentChoices.length > 0) {
        for (let i = 0; i < story.currentChoices.length; i++) {
          const choice = story.currentChoices[i]
          console.log("choice print", choice.text)
          print((i + 1) + ". " + choice.text, "choice")
        }
      }
    }

    function startTalk(entity) {
      showTalkBox()
      try {
        story.ChoosePathString(entity.name)
      } catch {
        error (`No Ink knot with name "${entity.name}"?`)
      }
      doRunStory()
    }

    const getFirstWord = (str) => {
      /* only looks at whitespace.
      has no concept of punctuation or word-forming characters
      so "   word(word2) word3   "
      will return
      "word(word2)" as first word! (NOT: "word")
      */
      const txt = str.trim()
      for (let i = 0; i < txt.length; i++) {
        const char = txt[i]
        if (char.trim() === "") {
          return txt.substring(0, i)
        }
        if (i === txt.length - 1) {
          return txt
        }
      }
      return ""
    }

    const getFirstWordAndRest = (str) => {
      if (str !== str.trim()) {
        throw new Error(`The function "getFirstWordAndRest" in module "utils.js" works
          only with white-space-trimmed strings. You passed a non-white-space trimmed string.`)
      }
      const firstWord = getFirstWord(str)
      return [firstWord, str.substring(firstWord.length)]
    }

    function preprocess(str) {
      let err = false
      let dataObj = {}
      let inkCode = ""
      const parts = str.split("\n@@@===")
      dataObj.header = processHeader(parts[0])
      adjustHeader(dataObj.header)
      dataObj.maps = processMaps(parts[1])
      inkCode = parts[2]
      return [err, dataObj, inkCode]
    }

    function adjustHeader(header) {
      for (const headerKey of Object.keys(header)) {
        const headerEntry = header[headerKey]
        for (const entryKey of Object.keys(headerEntry)) {
          headerEntry[entryKey] = applyHeaderRules(headerEntry, entryKey,
            headerEntry[entryKey], headerKey)
        }
      }
    }

    function applyHeaderRules(entry, key, value, headerKey) {
      //setCssVar
      if (headerKey === "text" && key === "color") {
        setCssVar("text-color", value)
      }

      if (headerKey === "choice" && key === "color") {
        setCssVar("choice-color", value)
      }

      if (headerKey === "text" && key === "bg") {
        setCssVar("bg", value)
      }

      if (headerKey === "border" && key === "color") {
        setCssVar("text-box-border-color", value)
      }

      if (headerKey === "border" && key === "border") {
        setCssVar("text-box-border-size", value === "yes" ? "16px" : "0px")
      }

      if (headerKey === "border" && key === "padding") {
        setCssVar("text-box-padding", value === "yes" ? "16px" : "0px")
      }

      if (key === "show") {
        if (value === "no") return " "
      }

      return value
    }

    function processHeader(str) {
      const lines = str.split("\n").map(n => n.trim()).filter(n => n)
      const obj = {}
      for (const line of lines) {
        let [key, rest] = getFirstWordAndRest(line)
        key = key.replace(":", "").trim()
        rest = rest.trim()
        if (rest.startsWith(":")) {
          //if story author does: "property : content"
          //instead of "property: content", fix it:
          rest = rest.substring(1).trim()
        }
        const subobj = {}
        obj[key] = subobj
        const subparts = rest.split(",").map(n => n.trim()).filter(n => n)
        for (subpart of subparts) {
          const parts = subpart.split(":")
          const key = parts[0].trim()
          let value = parts[1].trim()
          subobj[key] = value
        }
      }
      return obj
    }

    function processMaps(str) {
      const mapsObj = {}
      let firstMapName = ""
      const maps = str.split("\nMAP:").map(n => n.trim()).filter(n => n)
      for (const map of maps) {
        let map2 = map.trim()
        const [mapName, rest] = getFirstWordAndRest(map2)
        mapsObj[mapName] = createMap(rest)
        if (!firstMapName) firstMapName = mapName
      }
      mapsObj.$firstMapName = firstMapName
      return mapsObj
    }

    function createMap(str) {
      const lines = str.split("\n")
      let y = -1
      const grid = []
      for (const line of lines) {
        y++
        grid[y] = []
        let x = -1
        if (y > mapHeight) break
        for (const char of line) {
          x++
          if (x > mapWidth) break
          grid[y][x] = char
        }
      }
      adjustMap(grid)
      return grid
    }

    function startStory() {
      ctx = document.getElementById("map-canvas").getContext("2d")
      renderMap()
    }

    function getCurrentMap() {
      const map = authorData.maps[authorData.maps.$firstMapName]
      return map
    }

    function showTalkBox() {
      document.getElementById("play").style.display = "block"
    }

    function hideTalkBox() {
      document.getElementById("play").style.display = "none"
    }

    function renderMap() {
      hideTalkBox()
      const map = getCurrentMap()
      const spaceX = 14
      const spaceY = 20
      const fontSize = 14
      let ox = 240 - (player.x) * spaceX
      let oy = 160 - (player.y - 1) * spaceY
      ctx.font = '16px monospace';
      ctx.fillStyle = authorData.header.game.bg
      ctx.fillRect(0, 0, 480, 320)
      ctx.fillStyle = authorData.header.game.color
      loopThroughMap(map, (char, x, y) => {
        const distX = Math.abs(x - player.x)
        const distY = Math.abs(y - player.y)
        const dist = Math.sqrt(distX * distX + distY * distY * visionYStretch)
        let px = x * spaceX + ox
        let py = y * spaceY + oy
        if (dist > vision) {
          ctx.fillStyle = authorData.header.fog.color
          ctx.fillText(authorData.header.fog.show, px, py)
          ctx.fillStyle = authorData.header.game.color
          return
        }
        if (player.x === x && player.y === y) {
          ctx.fillStyle = authorData.header.player.color
          ctx.fillText(authorData.header.player.show, px, py)
          ctx.fillStyle = authorData.header.game.color
          return
        }
        let showChar = char
        if (authorData.header[char]?.show) showChar = authorData.header[char].show
        if (showChar === " ") return
        if (authorData.header[char]?.color) {
          ctx.fillStyle = authorData.header[char].color
          ctx.fillText(showChar, px, py)
          ctx.fillStyle = authorData.header.game.color
          return
        }
        ctx.fillText(showChar, px, py)
      })
      let i = -1
      for (const entity of entities) {
        i++
        if (player.x === entity.x && player.y === entity.y) return
        const distX = Math.abs(entity.x - player.x)
        const distY = Math.abs(entity.y - player.y)
        const dist = Math.sqrt(distX * distX + distY * distY * visionYStretch)
        if (distX > vision4Entity) continue
        let px = entity.x * spaceX + ox
        let py = entity.y * spaceY + oy
        ctx.fillStyle = authorData.header[entity.name]?.color || "red"
        ctx.fillText(authorData.header[entity.name]?.show || "@", px, py)
      }
    }

    function isEnglishLowerCaseLetter(char) {
      return /^[a-z]$/.test(char)
    }

    function adjustMap(map) {
      let collect = null
      loopThroughMap(map, (char, x, y) => {
        //console.log(char, x, y)
        if (isEnglishLowerCaseLetter(char) || char === ":") {
          if (!collect) {
            collect = char
          } else {
            collect += char
          }
          map[y][x] = "."
        } else {
          if (collect) {
            let xPos = 0
            if (collect.startsWith(":")) {
              xPos = x - collect.length
            } else {
              xPos = x - 1
            }
            entities.push({
              x: xPos,
              y,
              name: collect.replaceAll(":", ""),
            })
            collect = null
          }
        }
      })
    }

    function loopThroughMap(map, func) {
      let y = -1
      for (const item of map) {
        y++
        let x = -1
        for (const item2 of item) {
          x++
          func(item2, x, y)
        }
      }
    }

    function cls() {
      outputDiv.innerHTML = ""
    }

    function print(text, cssClass) {
      outputDiv.innerHTML += `<div class="${cssClass}">${text}</div>`
    }


//_inkStory.ChooseChoiceIndex (index);


  </script>
  </body>
</html>