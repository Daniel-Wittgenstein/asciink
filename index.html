<html>
  <head>
    <meta charset="utf-8">
    <title>asciink</title>
    <!--DEV-->
    <link rel="stylesheet" href="code-mirror-lib/codemirror.css">
    <!--END_DEV-->
    <style>
      :root {
        --bar-height: 32px;
        --bg: #222;
        --choice-color: yellow;
        --text-color: purple;
        --text-box-padding: 16px;
        --text-box-border-size: 16px;
        --text-box-border-color: white;
      }

      body {
        margin: 0;
        padding: 0;
        background: #222;
        color: white;
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
      }

      .code-editor-error-line {
        background: red;
        color: white;
      }

      #error-div {
        position: absolute;
        background: black;
        color: white;
        font-family: monospace;
      }

      .main {
        width: 100vw;
        max-width: 1600px;
        height: calc(100vh - var(--bar-height));
        display: flex;
        flex-direction: row;

        align-items: center;
        justify-content: center;
      }

      .bar {
        height: var(--bar-height);
        color: white;
        display: none;
        align-items: center;
        background: #050031
      }
      
      .left {
        width: 50%;
        height: 100%;
        display: none;
      }
      
      .right {
        width: 50%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      #story {
        width: 100%;
        height: 100%;
      }

      .CodeMirror {
        width: 100%;
        height: 100%;
      }

      .text {
        background: var(--bg);
        color: var(--text-color);
      }

      .choice {
        background: var(--bg);
        color: var(--choice-color);
      }

      .CodeMirror-gutters {
        background-color: #222;
        border-right: 2px solid #444;
      }

      .CodeMirror-linenumber {
          color: #fff;
      }

      .CodeMirror-overwrite .CodeMirror-cursor {
        width: auto;
        border-left: 1px solid red;
      }

      #play {
        width: 480px;
        height: 320px;
        position: absolute;
        font-family: monospace;
        display: none;
      }

      #play-inner {
        padding: 20px;
      }

      #play-inner-most {
        padding: var(--text-box-padding);
        background: var(--bg);
        border: var(--text-box-border-size) solid var(--text-box-border-color);
      }

      #map-canvas {
        width: 480px;
        height: 320px;
        border: 0px solid #888;
      }

      textarea {
        resize: none;
        background: #222;
        color: white;
        font-family: monospace;
        font-size: 14px;
        padding: 7px;
      }

      button {
        max-height: calc(var(--bar-height) - 4px);
        font-size: 12px;
        margin: 4px;
      }

    </style>
  </head>
  <body>
    <div class="app">
      <div class="main">
        <div class="left">
          <div id="story"></div>
        </div>
        <div class="right">
          <div id="error-div"></div>
          <div id="play">
            <div id="play-inner">
              <div id="play-inner-most">       
              </div>              
            </div>              
          </div>
          <canvas id="map-canvas" width="480" height="320"></canvas>
        </div>
      </div>
      <div class="bottom-bar bar">
        <button id="play-button">Play</button>
        <button id="save-button">Save</button>
        <button id="export-button">Export</button>
        <button id="help-button">Help</button>
      </div>
    </div>

  <!--DEV-->
  <script src="code-mirror-lib/codemirror.js"></script>
  <script src="./ink/ink-full.js"></script>
  <script src="./auto-generated/exportHtmlData.js"></script>
  <script src="./helpContents.js"></script>
  <!--END_DEV-->

  <!--INJECT-->

  <!--INJECT_STORY-->

  <script id="scr">

    const BLOCK_SEPARATOR = "@NEXT-BLOCK@"

    const delay = 400

    const mapWidth = 48
    const mapHeight = 24

    function error(msg, source) {
      //ink can throw several errors one after the other.
      //so we have to show them all, not just the first or the last one!
      msg = String(msg)
      console.log("COMPILE ERROR", msg, LINES_OFFSET)
      const match = msg.match(/line (\d+)/)
      let num = 0
      if (match) {
        num = Number(match[1])
        msg = msg.replace(/line (\d+)/, "")
      }
      errorDiv.innerHTML += `${msg}<br>`
      errorDiv.innerHTML += `source: ${source}<br>`
      const realLineNr = num + LINES_OFFSET
      errorDiv.innerHTML += `LINE: ${realLineNr}<br><br>`
      if (EDITOR) {
        const marginFromTop = 100
        codeMirror.addLineClass(realLineNr - 1, "wrap", "code-editor-error-line")
        codeMirror.scrollIntoView({line: realLineNr - 1, char: 1}, marginFromTop)
      }

    }

    const autoSave = "buffy summers"

    const vision = 7.5
    const vision4Entity = 5.5
    const visionYStretch = 1

    let codeMirror
    let outputDiv
    let story = null
    
    let authorData = null
    let entities = []
    let player = null

    let ctx = null

    let LINES_OFFSET = 0

    let EDITOR = true

    function initEditorView() {
      document.querySelector(".left").style.display = "block"
      document.querySelector(".bottom-bar").style.display = "flex"
    }

    function startExportedGame() {
      playIt()      
    }

    function resetGameState() {
      entities = []
      authorData = null
      player = {x: 3, y: 3}
    }

    let errorDiv

    window.onload = startApp
    function startApp() {

      if (!window.$exportedHtmlData) {
        EDITOR = false
      }

      if (EDITOR) initEditorView()

      outputDiv = document.getElementById("play-inner-most")
      errorDiv = document.getElementById("error-div")

      if (EDITOR) {
        codeMirror = CodeMirror(document.getElementById("story"), {
          value: "",
          indentUnit: 2,
          tabSize: 2,
          indentWithTabs: false,
          lineNumbers: true,
          lineWrapping: false,
          spellcheck: false,
          lineWrapping: true,
          extraKeys: {
            "Shift-Tab": "indentLess",
          },
        })

        codeMirror.on("focus", function() { cleanEditor() })  

      }

      document.addEventListener("keyup", (ev) => {
        const k = ev.key
        let oldX = player.x
        let oldY = player.y
        if (k === "1" || k === "2" || k === "3" || k === "4" || k === "5" || k === "6" ||
            k === "7" || k === "8" || k === "9") {
          const num = Number(k)
          takeTurn(num - 1)
          return
        }
        let walked = false
        if (k === "ArrowUp" || k === "w") {player.y --; walked = true}
        if (k === "ArrowDown" || k === "s") {player.y ++; walked = true}
        if (k === "ArrowRight" || k === "d") {player.x ++; walked = true}
        if (k === "ArrowLeft" || k === "a") {player.x --; walked = true}
        if (!walked) return
        const map = getCurrentMap()
        let char
        let block = false
        if (!map[player.y]) {
          block = true
        } else if (!map[player.y][player.x]) {
          block = true
        } else {
          char = map[player.y][player.x]
          if (!authorData.header[char] ||
            !authorData.header[char].pass || authorData.header[char].pass !== "yes") {
              block = true
          }
        }
        if (block) {
          player.x = oldX
          player.y = oldY
        }
        for (const entity of entities) {
          if (player.x === entity.x && player.y === entity.y) {
            renderMap()
            startTalk(entity)
            return
          }
        }
        if (oldX !== player.x || oldY !== player.y) {
          cls()
          renderMap()
        }
      })

      document.getElementById("play-button").addEventListener("click", (ev) => {
        playIt()
      })

      document.getElementById("save-button").addEventListener("click", (ev) => {
        saveProject()
      })

      document.getElementById("help-button").addEventListener("click", function(event) {
          event.preventDefault()
          const htmlContent = window.helpContents
          const newWindow = window.open()
          newWindow.document.write(htmlContent)
          newWindow.document.close()
      })


      document.getElementById("export-button").addEventListener("click", (ev) => {
        playIt()
        let ht = window.$exportedHtmlData.data
        ht = ht.replace(/\<title\>.*?\<\/title\>/, () => {
          return "<title>" + (authorData.header.title?.title || "unnamed game") + "</title>"
        })
        const xx = JSON.stringify({data:codeMirror.getValue()})
        ht = ht.replace("<!--INJECT_STORY-->", `
          <script>window.$userStoryData = ${xx}<\/script>
        `)
        download(ht, "export.html")
      })

      if (localStorage.getItem(autoSave)) {
        if (EDITOR) {
          codeMirror.setValue(localStorage.getItem(autoSave))
        }
      }

      if (!EDITOR) startExportedGame()
    }

    function saveProject() {
      if (!EDITOR) return
      localStorage.setItem(autoSave, codeMirror.getValue())
    }

    function takeTurn(choiceIndex) {
      if (choiceIndex > story.currentChoices.length - 1) {
        return
      }
      cls()
      story.ChooseChoiceIndex (choiceIndex)
      doRunStory()
    }

    function getSecondOccurrenceIndex(str, sub) {
      const i = str.indexOf(sub)
      if (i === -1) return -1
      const rest = str.substring(i + 1)
      const i2 = rest.indexOf(sub)
      if (i2 === -1) return -1
      const index = i2 + i + 1
      return index
    }

    function countLinesUntil(str, targetIndex) {
      let count = 0
      let i = -1
      for (const char of str) {
        i++
        if (i >= targetIndex) break
        if (char === "\n") count++
      }
      return count
    }

    function cleanEditor() {
      if (EDITOR) {
        for (let i = 0; i < codeMirror.lineCount(); i++) { //unfortunately, this is necessary
          codeMirror.removeLineClass(i, "wrap")
        }
      }
    }

    function playIt() {
      errorDiv.innerHTML = ""
      saveProject()
      outputDiv.innerHTML = ""
      let v = ""
      if (EDITOR) v = codeMirror.getValue()
      if (!EDITOR) v = window.$userStoryData.data
      
      //find second instance of str
      const secIndex = getSecondOccurrenceIndex(v, BLOCK_SEPARATOR)
      LINES_OFFSET = countLinesUntil(v, secIndex)

      resetGameState()

      const [err, dataObj, inkCode] = preprocess(v)

      console.log("dataObj", dataObj)
      if (err) {
        error(err)
        return
      }
      try {
        const compiler = new inkjs.Compiler(inkCode)
        compiler.OnError = (err) => {error(err, "compiler.OnError")}
        story = compiler.Compile()
        console.log(compiler, story)
      } catch(err) {
        //error(err, "catch")
        return
      }
      authorData = dataObj
      story.onError = (err) => error(err, "story.onError")
      startStory()
    }

    function download(html, fileName) {
      const blob = new Blob([html], {type: 'text/html'})
      const link = document.createElement("a")
      link.download = fileName
      link.href = window.URL.createObjectURL(blob)
      document.body.appendChild(link)
      link.click()
      document.body.removeChild(link)
    }

    function setCssVar(key, value) {
      document.documentElement.style.setProperty("--" + key, value)
    }

    function getDefaultSettings() {
      return {
        "title": {
            "title": "Unnamed Game"
        },
        "game": {
            "color": "white",
            "bg": "black"
        },
        "text": {
            "color": "white",
            "bg": "black"
        },
        "choice": {
            "color": "white"
        },
        "border": {
            "color": "blue",
            "padding": "yes",
            "border": "yes"
        },
        "player": {
            "color": "#0ff",
            "show": "⌖"
        },
        "fog": {
            "color": "#444",
            "show": "█"
        },
        ".": {
            "show": " ",
            "pass": "yes"
        },
        " ": {
            "show": " ",
            "pass": "yes"
        },
      }
    }

    function doRunStory() {
      while (story.canContinue) {
        const content = story.Continue()
        console.log("text print", content)
        print(content, "text")
      }
      if (story.currentChoices.length > 0) {
        for (let i = 0; i < story.currentChoices.length; i++) {
          const choice = story.currentChoices[i]
          console.log("choice print", choice.text)
          print((i + 1) + ". " + choice.text, "choice")
        }
      }
    }

    function startTalk(entity) {
      showTalkBox()
      try {
        story.ChoosePathString(entity.name)
      } catch {
        error (`No Ink knot with name "${entity.name}"?`)
      }
      doRunStory()
    }

    const getFirstWord = (str) => {
      /* only looks at whitespace.
      has no concept of punctuation or word-forming characters
      so "   word(word2) word3   "
      will return
      "word(word2)" as first word! (NOT: "word")
      */
      const txt = str.trim()
      for (let i = 0; i < txt.length; i++) {
        const char = txt[i]
        if (char.trim() === "") {
          return txt.substring(0, i)
        }
        if (i === txt.length - 1) {
          return txt
        }
      }
      return ""
    }

    const getFirstWordAndRest = (str) => {
      if (str !== str.trim()) {
        throw new Error(`The function "getFirstWordAndRest" in module "utils.js" works
          only with white-space-trimmed strings. You passed a non-white-space trimmed string.`)
      }
      const firstWord = getFirstWord(str)
      return [firstWord, str.substring(firstWord.length)]
    }

    function preprocess(str) {
      let err = false
      let dataObj = {}
      let inkCode = ""
      const parts = str.split(BLOCK_SEPARATOR)
      const defaultObj = getDefaultSettings()
      processHeader(defaultObj, parts[0])
      dataObj.header = defaultObj
      adjustHeader(dataObj.header)
      dataObj.maps = processMaps(parts[1])
      inkCode = parts[2]
      return [err, dataObj, inkCode]
    }

    function adjustHeader(header) {
      for (const headerKey of Object.keys(header)) {
        const headerEntry = header[headerKey]
        for (const entryKey of Object.keys(headerEntry)) {
          headerEntry[entryKey] = applyHeaderRules(headerEntry, entryKey,
            headerEntry[entryKey], headerKey)
        }
      }
    }

    function applyHeaderRules(entry, key, value, headerKey) {
      //setCssVar
      if (headerKey === "text" && key === "color") {
        setCssVar("text-color", value)
      }

      if (headerKey === "choice" && key === "color") {
        setCssVar("choice-color", value)
      }

      if (headerKey === "text" && key === "bg") {
        setCssVar("bg", value)
      }

      if (headerKey === "border" && key === "color") {
        setCssVar("text-box-border-color", value)
      }

      if (headerKey === "border" && key === "border") {
        setCssVar("text-box-border-size", value === "yes" ? "16px" : "0px")
      }

      if (headerKey === "border" && key === "padding") {
        setCssVar("text-box-padding", value === "yes" ? "16px" : "0px")
      }

      if (key === "show") {
        if (value === "no") return " "
      }

      return value
    }

    function processHeader(obj, str) {
      const lines = str.split("\n").map(n => n.trim()).filter(n => n)
      for (const line of lines) {
        if (line.startsWith("//")) {
          continue
        }
        let [key, rest] = getFirstWordAndRest(line)
        key = key.replace(":", "").trim()
        rest = rest.trim()
        if (rest.startsWith(":")) {
          //if story author does: "property : content"
          //instead of "property: content", fix it:
          rest = rest.substring(1).trim()
        }
        const subobj = {}
        obj[key] = subobj
        const subparts = rest.split(",").map(n => n.trim()).filter(n => n)
        for (subpart of subparts) {
          const parts = subpart.split(":")
          const key = parts[0].trim()
          let value = parts[1].trim()
          subobj[key] = value
        }
      }
    }

    function processMaps(str) {
      const mapsObj = {}
      let firstMapName = ""
      const maps = str.split("\nMAP:").map(n => n.trim()).filter(n => n)
      for (const map of maps) {
        let map2 = map.trim()
        const [mapName, rest] = getFirstWordAndRest(map2)
        mapsObj[mapName] = createMap(rest)
        if (!firstMapName) firstMapName = mapName
      }
      mapsObj.$firstMapName = firstMapName
      return mapsObj
    }

    function createMap(str) {
      const lines = str.split("\n")
      let y = -1
      const grid = []
      for (const line of lines) {
        y++
        grid[y] = []
        let x = -1
        if (y > mapHeight) break
        for (const char of line) {
          x++
          if (x > mapWidth) break
          grid[y][x] = char
        }
      }
      adjustMap(grid)
      return grid
    }

    function startStory() {
      ctx = document.getElementById("map-canvas").getContext("2d")
      renderMap()
    }

    function getCurrentMap() {
      const map = authorData.maps[authorData.maps.$firstMapName]
      return map
    }

    function showTalkBox() {
      document.getElementById("play").style.display = "block"
    }

    function hideTalkBox() {
      document.getElementById("play").style.display = "none"
    }

    function renderMap() {
      hideTalkBox()
      const map = getCurrentMap()
      const spaceX = 14
      const spaceY = 20
      const fontSize = 14
      let ox = 240 - (player.x) * spaceX
      let oy = 160 - (player.y - 1) * spaceY
      ctx.font = '16px monospace';
      ctx.fillStyle = authorData.header.game.bg
      ctx.fillRect(0, 0, 480, 320)
      ctx.fillStyle = authorData.header.game.color
      loopThroughMap(map, (char, x, y) => {
        const distX = Math.abs(x - player.x)
        const distY = Math.abs(y - player.y)
        const dist = Math.sqrt(distX * distX + distY * distY * visionYStretch)
        let px = x * spaceX + ox
        let py = y * spaceY + oy
        if (dist > vision) {
          ctx.fillStyle = authorData.header.fog.color
          ctx.fillText(authorData.header.fog.show, px, py)
          ctx.fillStyle = authorData.header.game.color
          return
        }
        if (player.x === x && player.y === y) {
          ctx.fillStyle = authorData.header.player.color
          ctx.fillText(authorData.header.player.show, px, py)
          ctx.fillStyle = authorData.header.game.color
          return
        }
        let showChar = char
        if (authorData.header[char]?.show) showChar = authorData.header[char].show
        if (showChar === " ") return
        if (authorData.header[char]?.color) {
          ctx.fillStyle = authorData.header[char].color
          ctx.fillText(showChar, px, py)
          ctx.fillStyle = authorData.header.game.color
          return
        }
        ctx.fillText(showChar, px, py)
      })
      let i = -1
      for (const entity of entities) {
        i++
        if (player.x === entity.x && player.y === entity.y) return
        const distX = Math.abs(entity.x - player.x)
        const distY = Math.abs(entity.y - player.y)
        const dist = Math.sqrt(distX * distX + distY * distY * visionYStretch)
        if (distX > vision4Entity) continue
        let px = entity.x * spaceX + ox
        let py = entity.y * spaceY + oy
        ctx.fillStyle = authorData.header[entity.name]?.color || "red"
        ctx.fillText(authorData.header[entity.name]?.show || "@", px, py)
      }
    }

    function isEnglishLowerCaseLetter(char) {
      return /^[a-z]$/.test(char)
    }

    function adjustMap(map) {
      let collect = null
      loopThroughMap(map, (char, x, y) => {
        //console.log(char, x, y)
        if (isEnglishLowerCaseLetter(char) || char === ":") {
          if (!collect) {
            collect = char
          } else {
            collect += char
          }
          map[y][x] = "."
        } else {
          if (collect) {
            let xPos = 0
            if (collect.startsWith(":")) {
              xPos = x - collect.length
            } else {
              xPos = x - 1
            }
            entities.push({
              x: xPos,
              y,
              name: collect.replaceAll(":", ""),
            })
            collect = null
          }
        }
      })
    }

    function loopThroughMap(map, func) {
      let y = -1
      for (const item of map) {
        y++
        let x = -1
        for (const item2 of item) {
          x++
          func(item2, x, y)
        }
      }
    }

    function cls() {
      outputDiv.innerHTML = ""
    }

    function print(text, cssClass) {
      outputDiv.innerHTML += `<div class="${cssClass}">${text}</div>`
    }

  </script>
  </body>
</html>